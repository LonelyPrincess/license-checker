#!/usr/bin/env node

const checker = require('license-checker');
const yargs = require('yargs');
var fs = require('fs');
const { string } = require('yargs');
const _ = require('lodash');

const now = new Date().toISOString();

const argv = yargs
    .option('failOn', {
      description: 'fail (exit with code 1) on the first occurrence of the licenses of the comma-separated list',
      type: 'string',
    })
    .option('generateOutputOn', {
      description: 'generates an output file only if any the licenses of the comma-separated list exist (output generated by default).',
      type: 'string',
    })
    .option('outputFileName', {
      description: 'name of the output file generated',
      type: 'string',
      default: `licence-report-${now}`
    })
    .option('errorReportFileName', {
      description: 'name of the file generated when a licence in the failOn option is found',
      type: 'string',
      default: `license-error-${now}`
    })
    .option('disableErrorReport', {
      description: 'flag to disable the error report file generation',
      type: 'boolean',
      default: false
    })
    .help()
    .alias('help', 'h')
    .argv;

const cleanOutput = packages => Object.entries(packages).map(([key, value]) => {
    const { path, licenseFile, ...rest } = value;
    const validInfo = {
      package_name: key,
      ...rest,
    };

    return validInfo;
  });

const createLicenseReport = ({ report }) => {
  const compiled = _.template(
    '|   Library   |  Version  |  License |    Repository   |\n|---|---|---|---|\n<% _.forEach(report, function(elem) { %>| <%- elem.package_name.split("@")[0] %> | <%- elem.package_name.split("@")[1] %> | <%- elem.licenses %> | <%- elem.repository %> |\n <% }); %>');

  const output = compiled({ 'report': report });
  fs.writeFileSync(
    `${argv.outputFileName}.md`,
    output, error => {
      if (error) throw error;
  });
  console.info(`${argv.outputFileName}.md created!`);
};

checker.init({
  start: __dirname,
}, (err, packages) => {
  if (err) {
    console.error('license-checker error:', err);
  } else {
    const cleanedPackages = cleanOutput(packages);

    if (argv.failOn) {
      const parsedFailOn = argv.failOn.split(',');
      const parsedFailOnArray = parsedFailOn.map(p => p.trim());


      const failOnOutput = cleanedPackages.filter(packageInfo => parsedFailOnArray.includes(packageInfo.licenses));

      // Generate report
      if (failOnOutput.length && !argv.disableErrorReport) {
        fs.writeFileSync(
          `${argv.errorReportFileName}.txt`,
          JSON.stringify(failOnOutput, null, "\t"), error => {
            if (error) throw error;
        });

        console.info(`${argv.errorReportFileName}.txt created!`);
      }

      // Check if should exit
      if (failOnOutput.length) {
        const failingLicensesArray = failOnOutput.map(p => p.licenses);
        const failingLicensesSet = new Set(failingLicensesArray);
        console.error('Found license defined by the --failOn flag: "' + Array.from(failingLicensesSet).join(', ') + '". Exiting.');
        process.exit(1);
      }
    }

    const parsedGenerateOutputOn = argv.generateOutputOn ? argv.generateOutputOn.split(',') : [];
    const parsedGenerateOutputOnArray = parsedGenerateOutputOn.map(p => p.trim());

    if (!parsedGenerateOutputOnArray.length || cleanedPackages.some(p => parsedGenerateOutputOnArray.includes(p.licenses))) {
      console.info('License check completed! No forbidden licenses packages found.');
      console.log('cleanedPackages', cleanedPackages);
      createLicenseReport({ report: cleanedPackages });
    }
  }
});